<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Aprendendo TDD na prática</title>
    <link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-1.18.0.css">
    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">
  </head>
  <body>
    <div id='main' style='padding: 2em;'>
      <h1>Calculadora de troco de uma máquina de venda</h1>
      <h2>Calcule o troco de acordo com o preço do produto e dinheiro recebido</h2>
    </div>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="https://code.jquery.com/qunit/qunit-1.18.0.js"></script>

    <script>
      // Constantes globais
      const NOTAS_DISPONIVEIS = [100, 50, 20, 10, 5, 2, 1];
      
      /**
       * Calcula o troco em notas a partir do preço do produto e valor pago
       * Considera o estoque disponível de cada nota na máquina
       * 
       * @param {number} precoDoProduto - Preço do produto em reais
       * @param {number} valorPago - Valor pago pelo cliente em reais
       * @param {Object} estoque - Objeto com a quantidade disponível de cada nota (ex: {100: 2, 50: 5})
       * @returns {number[]} Array com as notas que compõem o troco, em ordem decrescente
       * @throws {Error} Se não for possível dar o troco exato com o estoque disponível
       */
      function calcularTroco(precoDoProduto, valorPago, estoque) {
        const valorTroco = calcularValorDoTroco(precoDoProduto, valorPago);
        
        validarValorDoTroco(valorTroco);
        
        if (trocoEhZero(valorTroco)) {
          return [];
        }
        
        return encontrarNotasParaTroco(valorTroco, estoque);
      }
      
      /**
       * Calcula o valor do troco
       * 
       * @param {number} precoDoProduto - Preço do produto
       * @param {number} valorPago - Valor pago pelo cliente
       * @returns {number} Valor do troco
       */
      function calcularValorDoTroco(precoDoProduto, valorPago) {
        return valorPago - precoDoProduto;
      }
      
      /**
       * Valida se o valor do troco é válido
       * 
       * @param {number} valorTroco - Valor do troco a ser validado
       * @throws {Error} Se o valor do troco for negativo
       */
      function validarValorDoTroco(valorTroco) {
        if (valorTroco < 0) {
          throw new Error('O valor pago não pode ser menor que o preço do produto');
        }
      }
      
      /**
       * Verifica se o troco é zero
       * 
       * @param {number} valorTroco - Valor do troco
       * @returns {boolean} True se o troco for zero
       */
      function trocoEhZero(valorTroco) {
        return valorTroco === 0;
      }
      
      /**
       * Encontra as notas necessárias para compor o troco considerando o estoque
       * 
       * @param {number} valorTroco - Valor do troco a ser calculado
       * @param {Object} estoque - Objeto com quantidade disponível de cada nota
       * @returns {number[]} Array com as notas que compõem o troco
       * @throws {Error} Se não for possível dar o troco exato
       */
      function encontrarNotasParaTroco(valorTroco, estoque) {
        const estoqueDisponivel = clonarEstoque(estoque);
        const resultado = buscarCombinacaoDeNotas(valorTroco, estoqueDisponivel, 0);
        
        if (naoEncontrouSolucao(resultado)) {
          lancarErroTrocoImpossivel();
        }
        
        return resultado;
      }
      
      /**
       * Clona o objeto de estoque para não modificar o original
       * 
       * @param {Object} estoque - Estoque original
       * @returns {Object} Cópia do estoque
       */
      function clonarEstoque(estoque) {
        return { ...estoque };
      }
      
      /**
       * Verifica se não foi encontrada solução
       * 
       * @param {Array|null} resultado - Resultado da busca
       * @returns {boolean} True se não encontrou solução
       */
      function naoEncontrouSolucao(resultado) {
        return resultado === null;
      }
      
      /**
       * Lança erro quando não é possível fornecer o troco
       * 
       * @throws {Error} Erro indicando impossibilidade de dar o troco
       */
      function lancarErroTrocoImpossivel() {
        throw new Error('Não é possível fornecer o troco exato com as notas disponíveis no estoque');
      }
      
      /**
       * Busca recursivamente uma combinação de notas usando backtracking
       * Algoritmo tenta usar o máximo de notas grandes primeiro para otimizar
       * 
       * @param {number} valorRestante - Valor que ainda precisa ser completado
       * @param {Object} estoque - Estoque atual de notas
       * @param {number} indiceNota - Índice da nota atual no array NOTAS_DISPONIVEIS
       * @returns {number[]|null} Array com as notas ou null se não houver solução
       */
      function buscarCombinacaoDeNotas(valorRestante, estoque, indiceNota) {
        if (trocoCompleto(valorRestante)) {
          return [];
        }
        
        if (naoHaMaisNotasParaTestar(indiceNota)) {
          return null;
        }
        
        const notaAtual = obterNotaAtual(indiceNota);
        const maxNotasUsaveis = calcularMaximoDeNotasUsaveis(valorRestante, notaAtual, estoque);
        
        return tentarQuantidadesDeNotas(valorRestante, estoque, indiceNota, notaAtual, maxNotasUsaveis);
      }
      
      /**
       * Verifica se o troco foi completado
       * 
       * @param {number} valorRestante - Valor restante a ser completado
       * @returns {boolean} True se o troco está completo
       */
      function trocoCompleto(valorRestante) {
        return valorRestante === 0;
      }
      
      /**
       * Verifica se não há mais notas para testar
       * 
       * @param {number} indiceNota - Índice atual da nota
       * @returns {boolean} True se não há mais notas
       */
      function naoHaMaisNotasParaTestar(indiceNota) {
        return indiceNota >= NOTAS_DISPONIVEIS.length;
      }
      
      /**
       * Obtém a nota atual baseada no índice
       * 
       * @param {number} indiceNota - Índice da nota
       * @returns {number} Valor da nota
       */
      function obterNotaAtual(indiceNota) {
        return NOTAS_DISPONIVEIS[indiceNota];
      }
      
      /**
       * Calcula o máximo de notas que podem ser usadas
       * Considera tanto o estoque disponível quanto o valor necessário
       * 
       * @param {number} valorRestante - Valor restante a ser completado
       * @param {number} nota - Valor da nota
       * @param {Object} estoque - Estoque disponível
       * @returns {number} Quantidade máxima de notas que podem ser usadas
       */
      function calcularMaximoDeNotasUsaveis(valorRestante, nota, estoque) {
        const quantidadeNoEstoque = obterQuantidadeNoEstoque(nota, estoque);
        const quantidadeNecessaria = calcularQuantidadeNecessaria(valorRestante, nota);
        
        return Math.min(quantidadeNoEstoque, quantidadeNecessaria);
      }
      
      /**
       * Obtém a quantidade de uma nota no estoque
       * 
       * @param {number} nota - Valor da nota
       * @param {Object} estoque - Estoque disponível
       * @returns {number} Quantidade disponível no estoque (verifica se estoque[nota] > 0)
       */
      function obterQuantidadeNoEstoque(nota, estoque) {
        return estoque[nota] || 0;
      }
      
      /**
       * Calcula quantas notas seriam necessárias para o valor restante
       * 
       * @param {number} valorRestante - Valor restante
       * @param {number} nota - Valor da nota
       * @returns {number} Quantidade necessária de notas
       */
      function calcularQuantidadeNecessaria(valorRestante, nota) {
        return Math.floor(valorRestante / nota);
      }
      
      /**
       * Tenta diferentes quantidades de uma nota (do máximo ao mínimo) usando backtracking
       * 
       * @param {number} valorRestante - Valor restante a completar
       * @param {Object} estoque - Estoque atual
       * @param {number} indiceNota - Índice da nota atual
       * @param {number} nota - Valor da nota
       * @param {number} maxQuantidade - Quantidade máxima de notas que podem ser usadas
       * @returns {number[]|null} Array com as notas ou null se não houver solução
       */
      function tentarQuantidadesDeNotas(valorRestante, estoque, indiceNota, nota, maxQuantidade) {
        // Tenta do máximo ao mínimo (incluindo zero) para encontrar uma solução
        for (let quantidade = maxQuantidade; quantidade >= 0; quantidade--) {
          const solucao = tentarUsarQuantidadeDeNotas(
            valorRestante, 
            estoque, 
            indiceNota, 
            nota, 
            quantidade
          );
          
          if (solucao !== null) {
            return solucao;
          }
        }
        
        return null;
      }
      
      /**
       * Tenta usar uma quantidade específica de notas
       * 
       * @param {number} valorRestante - Valor restante
       * @param {Object} estoque - Estoque atual
       * @param {number} indiceNota - Índice da nota
       * @param {number} nota - Valor da nota
       * @param {number} quantidade - Quantidade de notas a usar
       * @returns {number[]|null} Array com as notas ou null se não funcionou
       */
      function tentarUsarQuantidadeDeNotas(valorRestante, estoque, indiceNota, nota, quantidade) {
        const novoValorRestante = calcularNovoValorRestante(valorRestante, nota, quantidade);
        const estoqueAtualizado = decrementarEstoque(estoque, nota, quantidade);
        
        const resultadoProximasNotas = buscarCombinacaoDeNotas(
          novoValorRestante,
          estoqueAtualizado,
          indiceNota + 1
        );
        
        if (resultadoProximasNotas !== null) {
          return construirSolucao(nota, quantidade, resultadoProximasNotas);
        }
        
        return null;
      }
      
      /**
       * Calcula o novo valor restante após usar determinada quantidade de notas
       * 
       * @param {number} valorRestante - Valor restante atual
       * @param {number} nota - Valor da nota
       * @param {number} quantidade - Quantidade de notas usadas
       * @returns {number} Novo valor restante
       */
      function calcularNovoValorRestante(valorRestante, nota, quantidade) {
        return valorRestante - (nota * quantidade);
      }
      
      /**
       * Decrementa o estoque após usar uma quantidade de notas (estoque[cedula] - quantidade)
       * 
       * @param {Object} estoque - Estoque atual
       * @param {number} nota - Valor da nota
       * @param {number} quantidade - Quantidade de notas usadas
       * @returns {Object} Novo estoque atualizado
       */
      function decrementarEstoque(estoque, nota, quantidade) {
        const estoqueAtualizado = clonarEstoque(estoque);
        estoqueAtualizado[nota] = obterQuantidadeNoEstoque(nota, estoque) - quantidade;
        return estoqueAtualizado;
      }
      
      /**
       * Constrói a solução final combinando as notas usadas com o resultado das próximas notas
       * 
       * @param {number} nota - Valor da nota usada
       * @param {number} quantidade - Quantidade de notas usadas
       * @param {number[]} resultadoProximasNotas - Resultado das próximas notas
       * @returns {number[]} Array completo com todas as notas da solução
       */
      function construirSolucao(nota, quantidade, resultadoProximasNotas) {
        const notasUsadas = criarArrayDeNotas(nota, quantidade);
        return [...notasUsadas, ...resultadoProximasNotas];
      }
      
      /**
       * Cria um array com a quantidade especificada de notas
       * 
       * @param {number} nota - Valor da nota
       * @param {number} quantidade - Quantidade de notas
       * @returns {number[]} Array com as notas
       */
      function criarArrayDeNotas(nota, quantidade) {
        const notas = [];
        for (let i = 0; i < quantidade; i++) {
          notas.push(nota);
        }
        return notas;
      }
    </script>

    <script>
      test('calcularTroco(1,1) deve retornar [] - Um array vazio', (assert) => {
        const estoque = { 100: 10, 50: 10, 20: 10, 10: 10, 5: 10, 2: 10, 1: 10 }
        const trocoCalculado = calcularTroco(1, 1, estoque) // Sem troco, apenas um array vazio
        const trocoEsperado = []
        assert.deepEqual(trocoCalculado, trocoEsperado) // 'deepEqual' usado para comparar arrays, veja mais em https://api.qunitjs.com/assert/deepEqual/
      })

       test('calcularTroco(215, 300) deve retornar [50, 20, 10, 5]', (assert) => {
        const estoque = { 100: 10, 50: 10, 20: 10, 10: 10, 5: 10, 2: 10, 1: 10 }
        const trocoCalculado = calcularTroco(215, 300, estoque) // Esperado um array contendo [50, 20, 10, 5]
        const trocoEsperado = [50, 20, 10, 5]
        assert.deepEqual(trocoCalculado, trocoEsperado)
      })

      test('calcularTroco(486, 600) deve retornar [100, 10, 2, 2]', (assert) => {
        const estoque = { 100: 10, 50: 10, 20: 10, 10: 10, 5: 10, 2: 10, 1: 10 }
        const trocoCalculado = calcularTroco(486, 600, estoque)
        const trocoEsperado = [100, 10, 2, 2]
        assert.deepEqual(trocoCalculado, trocoEsperado)
      })

       test('calcularTroco(12, 200) deve retornar [100, 50, 20, 10, 5, 2, 1]', (assert) => {
        const estoque = { 100: 10, 50: 10, 20: 10, 10: 10, 5: 10, 2: 10, 1: 10 }
        const trocoCalculado = calcularTroco(12, 200, estoque)
        const trocoEsperado = [100, 50, 20, 10, 5, 2, 1]
        assert.deepEqual(trocoCalculado, trocoEsperado)
      })

      // RED: Teste que falha - O algoritmo guloso tenta pegar nota de 50 que não existe no estoque
      test('calcularTroco com estoque limitado: troco de 80 com estoque {100:1, 50:0, 20:5, 10:10} deve retornar [20,20,20,20]', (assert) => {
        const estoque = { 100: 1, 50: 0, 20: 5, 10: 10, 5: 10, 2: 10, 1: 10 }
        const trocoCalculado = calcularTroco(20, 100, estoque) // Troco de 80
        const trocoEsperado = [20, 20, 20, 20] // Algoritmo guloso falharia tentando usar nota de 50
        assert.deepEqual(trocoCalculado, trocoEsperado)
      })
    </script>

  </body>
</html>